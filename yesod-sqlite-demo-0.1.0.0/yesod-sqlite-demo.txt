-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/artemmavrin/yesod-sqlite-demo#readme</a>
@package yesod-sqlite-demo
@version 0.1.0.0

module Expr
data Expr
Lit :: Double -> Expr
Var :: Text -> Expr
Neg :: Expr -> Expr
Add :: Expr -> Expr -> Expr
Sub :: Expr -> Expr -> Expr
Mul :: Expr -> Expr -> Expr
Div :: Expr -> Expr -> Expr
evaluateExpr :: Map Text Double -> Expr -> Maybe Double
isValidName :: Text -> Bool
parseExpr :: Stream s Identity Char => s -> Either ParseError Expr
variablesOf :: Expr -> Set Text
instance GHC.Show.Show Expr.Expr

module Foundation
data Variable
Variable :: !Text -> !Double -> !UTCTime -> !UTCTime -> Variable
[variableName] :: Variable -> !Text
[variableValue] :: Variable -> !Double
[variableCreated] :: Variable -> !UTCTime
[variableUpdated] :: Variable -> !UTCTime
type VariableId = Key Variable
migrateAll :: Migration
entityDefListFormigrateAll :: [EntityDef]
data App
App :: ConnectionPool -> App
[connectionPool] :: App -> ConnectionPool
type Handler = HandlerFor App
type Widget = WidgetFor App ()
resourcesApp :: [ResourceTree String]
instance GHC.Read.Read (Yesod.Routes.Class.Route Foundation.App)
instance GHC.Classes.Eq (Yesod.Routes.Class.Route Foundation.App)
instance GHC.Show.Show (Yesod.Routes.Class.Route Foundation.App)
instance Yesod.Routes.Class.ParseRoute Foundation.App
instance Yesod.Routes.Class.RenderRoute Foundation.App
instance Yesod.Routes.Class.RouteAttrs Foundation.App
instance Yesod.Core.Class.Yesod.Yesod Foundation.App
instance Yesod.Persist.Core.YesodPersist Foundation.App
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Database.Persist.Class.PersistEntity.PersistEntity Foundation.Variable
instance Database.Persist.Class.PersistField.PersistField Foundation.Variable
instance Database.Persist.Sql.Class.PersistFieldSql Foundation.Variable
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Foundation.Variable
instance Data.Aeson.Types.ToJSON.ToJSON Foundation.Variable
instance Data.Aeson.Types.FromJSON.FromJSON Foundation.Variable
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Entity Foundation.Variable)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Entity Foundation.Variable)
instance Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Foundation.Variable
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Foundation.Variable
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Foundation.Variable (Database.Persist.Class.PersistEntity.Key Foundation.Variable)
instance Database.Persist.Class.PersistEntity.SymbolToField "name" Foundation.Variable Data.Text.Internal.Text
instance Database.Persist.Class.PersistEntity.SymbolToField "value" Foundation.Variable GHC.Types.Double
instance Database.Persist.Class.PersistEntity.SymbolToField "created" Foundation.Variable Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.Persist.Class.PersistEntity.SymbolToField "updated" Foundation.Variable Data.Time.Clock.Internal.UTCTime.UTCTime

module Model.PostEvalRequest
data PostEvalRequest
instance Data.Aeson.Types.ToJSON.ToJSON Model.PostEvalRequest.PostEvalRequest
instance Data.Aeson.Types.FromJSON.FromJSON Model.PostEvalRequest.PostEvalRequest

module Model.PutVariableRequest
data PutVariableRequest
instance Data.Aeson.Types.ToJSON.ToJSON Model.PutVariableRequest.PutVariableRequest
instance Data.Aeson.Types.FromJSON.FromJSON Model.PutVariableRequest.PutVariableRequest

module Handler

-- | Handle <tt>/variables GET</tt> requests by returning either <i>all</i>
--   variables, or, if the <tt>name</tt> query parameter exists, the
--   variable picked out by that parameter (if it exists).
getVarsR :: Handler TypedContent

-- | Handle <tt>/variables/{name} GET</tt> requests for a single variable
--   name by returning the variable with that name, if it exists. If it
--   does not exist, a 404 error response is returned.
getVarR :: Text -> Handler TypedContent

-- | Handle <tt>/variables POST</tt> requests by creating or updating
--   multiple variables at once. The variables to be updated are specified
--   in the request body, which is a JSON object whose keys are variable
--   names and values are the corresponding values. E.g.
--   
--   <pre>
--   {"a": 10, "b": -0.5}
--   </pre>
postVarsR :: Handler ()

-- | Handle <tt>/variables/{name} PUT</tt> requests by creating or updating
--   a single variable. The name of the variable to be updated is specified
--   in the request URL slug, and the value to assign to that variable is
--   represented in the request body as a JSON object of the form
--   
--   <pre>
--   {"value": 100}
--   </pre>
putVarR :: Text -> Handler ()

-- | Handle <tt>/variables/{name} DELETE</tt> requests by deleting the
--   variable with the given name. If a variable with the given name
--   doesn't exist, nothing happens.
deleteVarR :: Text -> Handler ()

-- | Handle <tt>/ POST</tt> requests by evaluating the expression in the
--   request body, which should be a JSON object like
--   
--   <pre>
--   {"expr": "a*b + 100/(c-d)"}
--   </pre>
--   
--   If any of the variables occurring in the expression aren't defined in
--   the variable store, then a 404 is returned.
postEvalR :: Handler TypedContent

module Application
main :: IO ()
instance Yesod.Core.Class.Dispatch.YesodDispatch Foundation.App
